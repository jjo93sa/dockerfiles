#!/bin/bash
#
# Title:  build-all
#
# Description:
#   Create an image for each Dockerfile found in a directory. build-all uses
#   an experimental Docker feature, buildx, which allows us to build
#   multi-platform images, that is images with manifests for multiple
#   architectures. Script defaults to building arm, arm64 and amd64 images.
#
#   Attempts to use GNU parallel (https://www.gnu.org/software/parallel/)
#   to speed-up the image creation & push to a registry. See the help text by
#   running ./build-all -h.
#
#   We define three types of Dockerfile to build:
#     Type 1 - Standard Docker images, which may be used standalone or as the
#              basis for another image.
#     Type 2 - Base images, which are those that may not be used standalone,
#              but are intended to be used as the base of another Docker image
#     Type 3 - These are images derived from a Type 1 or Type 2 image, which
#              implies that the parent images must be built before the Type 3
#              files.
#
#   We ensure that the Type 1 and 2 images are built first. Type 3 images are
#   listed in a file called "subordinate". This file must have blank line if
#   no dependent, or Type 3 Docker files exist, otherwise no images will be
#   built.
#
# Dependencies:
#   (1) Assumes that the Dockerfiles are contained in a structure like this:
#       ./project-name/Dockerfile
#   (2) Assumes any Type 3 Docker files are listed in a file called
#       "subordinate" in the root of the Docker file structure. (See example
#       in this repo.)
#
# Credits:
#   Heavily based on the build-all script of jessfraz, see:
#   https://github.com/jessfraz/dockerfiles/blob/master/build-all.sh
#
# Usage:
#   Usage of this file is very simple:
#
#   (0) Login to your Docker registry (the one specified with the -r switch);
#   (1) Place this script in the root of your Dockerfile project;
#   (2) Execute the script ./build-all with the appropriate options, which are
#       described below. In addition, two environment variables are used to
#       control the docker build command:
#       NO_CACHE - which is used to set the --no-cache switch &
#       QUIET - which is used to set the -q switch
#   (3) Check the build-errors.txt file for any problems during the build.
#
# Maintainer:
#   dr.j.osborne@gmail.com
#
# License:
#   MIT, see file in repository root.
#
set -eu
set -o pipefail

# Get our path & name
SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

ERROR_FILE="$(pwd)/build-errors.txt"

function box
{
    t="xx$1xx"
    c=${2:-=}
    echo ${t//?/$c}
    echo "$c $1 $c"
    echo ${t//?/$c}
}

function info
{
    tput setaf 4
    box "$@"
    tput sgr0
}

function success
{
    tput setaf 2
    box "$@"
    tput sgr0
}

function fail
{
    tput setaf 1
    box "$@"
    tput sgr0
}


function help
{
cat <<End-of-message

build-all - build all Docker images described by Dockerfiles in a directory

Synopsis:
build-all [-h] -a ARCH1,ARCH2 -b JOBS -d DIR -m REGISTRY -r REGISTRY -t TAG

build-all -h        Print this help message and exit
          -a ARCH   Comma-separated list of platforms to build
                    Docker buildx is an experimental feature
                    default: linux/arm,linux/arm64,linux/amd64
          -b JOBS   Jobs count to use if GNU Parallel is installed
                    default: 1
          -d DIR    Set the Dockerfile search directory to DIR
                    default: current working directory
          -m REG    Only build Docker images missing from REG.
                    default r.j2o.it
          -r REG    Set the upstream registry to REG
                    default: rw.j2o.it
          -t TAG    Set the tag to apply to new images
                    default: latest

End-of-message
}

function build_push()
{
    # Parameters
    # $1 - Registry
    # $2 - Platform list
    # $3 - Image name
    # $4 - Tag
    # $5 - build directory

    local BLD_DIR=$5
    local BLD_STR="$1/$3:$4"

    # Some environment variable from the host to control how we build
    QUIET=${QUIET+-q}
    NO_CACHE=${NO_CACHE+--no-cache}

    # Build & push the image. buildx will build multiplatform images.
    echo "Building $BLD_STR with context $5"
    docker buildx build --pull --platform "${2}" \
        -t "${BLD_STR}" \
        --push "${5}" \
        || return 1

    success  "SUCCESS: built & pushed $BLD_STR"
}

function process_files()
{
    # Parameters
    # $1 - Registry
    # $2 - Arch list (buildx --platform)
    # $3 - Tag
    # $4 - File path from find

    # $4 has format: path/to/wget/Dockerfile
    local BUILD_DIR="${4%\/Dockerfile}" # Gives us: path/to/wget
    local IMAGE="${BUILD_DIR##*\/}" # Gives us: wget

    # Subshell
    {
        info "Starting build for: $IMAGE"

        # build_push $REG $PLATFORM $IMAGE $TAG $BUILD_DIR
        $SCRIPT build_push "${1}" "${2}" "${IMAGE}" "$3" "${BUILD_DIR}"
    } || {
        fail "FAIL: Building ${IMAGE}:${3} FAILED with error $?" | tee -a $ERROR_FILE
    }
    echo
}

main()
{
    EXISTING=""

    # Let's process the command line flags
    while getopts ":a:b:d:hm:r:t:" opt; do
        case $opt in
            a)
                # This is the comma-separated list of architectures
                IMG_ARC="${OPTARG}"
                ;;
            b)
                # This is the number of parallel jobs
                MAX_JOB="${OPTARG}"
                ;;
            d)
                # This is the docker directory containing all image/Dockerfile
                DCF_DIR="${OPTARG}"
                ;;
            h)
                # Display help and exit
                help
                exit 1
                ;;
            m)
                # Only build docker images missing in the registry (cf dir
                # specified with -d)
                export EXISTING=$(mktemp)
                CMP_REG="${OPTARG}"
                ;;
            r)
                # This is the registry to use for the push
                OUR_REG="${OPTARG}"
                ;;
            t)
                # This is the tag to use for the new image
                OUR_TAG="${OPTARG}"
                ;;
            \?)
                echo "$SCRIPT: invalid option supplied: -$OPTARG"
                exit 1
                ;;
            :)
                echo "$SCRIPT: -$OPTARG requires an argument"
                exit 1
                ;;
        esac
    done

    # Use the command line params, or the following defaults:
    DCF_DIR="${DCF_DIR:-$(pwd)}"
    IMG_ARC="${IMG_ARC:-linux/arm,linux/arm64,linux/amd64}"
    OUR_REG="${OUR_REG:-rw.j2o.it}"
    CMP_REG="${CMP_REG:-r.j2o.it}"
    MAX_JOB="${MAX_JOB:-1}"
    OUR_TAG="${OUR_TAG:-latest}"

    if [ -n "$EXISTING" ]
    then
        info "Getting repository list for ${CMP_REG}"

        # -m set; use r.j3ss.co/reg to list the existing docker repositories
        docker run r.j3ss.co/reg ls "${CMP_REG}" 2>/dev/null |
            awk 'NR>2 {print $1}' > "${EXISTING}"
    fi

    IFS=$'\n'
    # Generate a list of Dockerfiles (type 1 and 2):
    # 1) List all Dockerfiles in the specified directory;
    # 2) From this list we remove the subordinate group;
    # 3) Then we remove (if -m given) the existing containers in registry.
    # NB this array can be unbound!
    DCF_LIST=(  $(find -L ${DCF_DIR} -iname "*Dockerfile" |
        grep -vf ${DCF_DIR}/subordinate |
        if [ -e "$EXISTING" ]; then grep -vf "${EXISTING}" || true; else cat; fi ) )

    # Generate a list of Dockerfiles (type 3):
    # 1) List all Dockerfiles in the specified directory;
    # 2) From this list we select only the subordinate group present;
    # 3) Then we remove (if -m given) the existing containers in registry.
    # NB this array can be unbound!
    DEP_LIST=( $(find -L ${DCF_DIR} -iname "*Dockerfile" |
        grep -f ${DCF_DIR}/subordinate  |
        if [ -e "$EXISTING" ]; then grep -vf "${EXISTING}" || true; else cat; fi ) )
    unset IFS

    #IFS=',' read -ra ARC_LIST <<< "$IMG_ARC"

    # Type 1 & 2, checking for unbound array:
    if [[ ! -z "${DCF_LIST[@]:+${DCF_LIST[@]}}" ]]
    then
        info "Building ${#DCF_LIST[@]} type 1 and 2 images"
        if [ -x "$(command -v parallel)" ]
        then
            parallel -u -j "${MAX_JOB}" $SCRIPT process_files "${OUR_REG}" \
                "${IMG_ARC}" "$OUR_TAG" "{1}" ::: "${DCF_LIST[@]}"
        else
            for DCF in "${DCF_LIST[@]}"
            do
                $SCRIPT process_files "$OUR_REG" "$IMG_ARC" "$OUR_TAG" "$DCF"
            done
        fi
    else
        info "No type 1 or 2 images to build"
    fi

    # Type 3, checking for unbound array:
    if [[ ! -z "${DEP_LIST[@]:+"${DEP_LIST[@]}"}" ]]
    then
        info "Building ${#DEP_LIST[@]} type 3 images"
        if [ -x "$(command -v parallel)" ]
        then
            parallel -u -j "${MAX_JOB}" $SCRIPT process_files "${OUR_REG}" \
                "${IMG_ARC}" "$OUR_TAG" "{1}" ::: "${DEP_LIST[@]}"
        else
            for DEP in "${DEP_LIST[@]:+${DEP_LIST[@]}}"
            do
                $SCRIPT process_files "$OUR_REG" "$IMG_ARC" "$OUR_TAG" "$DEP"
            done
        fi
    else
            info "No type 3 images to build"
    fi

    exit 0
}

if declare -f -- "$1" &> /dev/null
then
    # We've been called like this: path/script function <params>
    "$@"
else
    # We've been called without a function name, so execute main
    main "$@"
fi


