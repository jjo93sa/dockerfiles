#!/bin/bash
#
# Title:  build-all
#
# Description:
#   Script to create an image for each Dockerfile found in a directory. Will
#   build Docker images for multiple architectures (configuration-dependent).
#   Uses GNU parallel (https://www.gnu.org/software/parallel/) in an attempt
#   to speed-up the image creation & push to a registry. See the help text by
#   running ./build-all -h.
#
#   We define three types of Dockerfile to build:
#     Type 1 - Sandard Docker images, which may be used standalone or as the
#              basis for another image.
#     Type 2 - Base images, which are those that may not be used standalone,
#              but are intended to be used as the base of another Docker image
#     Type 3 - These are images derived from a Type 1 or Type 2 image, which
#              implies that the parent images must be built before the Type 3
#              files.
#
#   We ensure that the Type 1 and 2 images are built first. Determination of
#   image type is performed by examining the name of the directory containing
#   the Dockerfile. Any directory name including an underscore (_) is deemed to
#   be a Type 3 image. For example, cron_certbot is a container derived from
#   Type 2 image cron.
#
# Dependencies:
#   (1) Assumes that the Dockerfiles are contained in a structure like this:
#       ./project-name/Dockerfile
#   (2) Assumes any Dockerfile-containing directory with _ in the name must be
#       built at the end of the queue (to ensure any base components are built)
#
# Credits:
#   Heavily based on the build-all script of jessfraz, see:
#   https://github.com/jessfraz/dockerfiles/blob/master/build-all.sh
#
# Usage:
#   Usage of this file is very simple:
#
#   (0) Login to your Docker registry (the one specified woth the -r switch);
#   (1) Place this script in the root of your Dockerfile project;
#   (2) Edit the parameter R_REG for a read-only registry
#   (2) Execute the script ./build-all with the appropriate options, which are
#       summarized as:
#       build-all -h        Print help and exit
#           -a ARCH   Comma-separated list of architectures to build; default:
#                     x86-64. Building for foreign architectures is system
#                     dependent
#           -b JOBS   Jobs count to use if GNU Parallel is installed; default: 2
#           -d DIR    Set the Dockerfile search directory to DIR; default: current
#                     working directory
#           -r REG    Set the upstream registry to REG; default: rw.j2o.it
#           -t TAG    Set the tag to apply to new images; default: latest
#   (3) Check the buiild-errors.txt file for any problems during the build
#
# Maintainer:
#   dr.j.osborne@gmail.com
#
# License:
#   MIT, see file in repository root.
#
set -e
set -o pipefail

# Get our path & name
SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

ERROR_FILE="$(pwd)/build-errors.txt"

function help()
{
cat <<End-of-message

build-all - build all Docker images described by Dockerfiles in a directory

Synopsis:
build-all [-h] -a ARCH1,ARCH2 -b JOBS -d DIR -r REGISTRY -t TAG

build-all -h        Print this help message and exit
          -a ARCH   Comma-separated list of architectures to build; default:
                    x86-64. Building for foreign architectures is system
                    dependent
          -b JOBS   Jobs count to use if GNU Parallel is installed; default: 2
          -d DIR    Set the Dockerfile search directory to DIR; default: current
                    working directory
          -r REG    Set the upstream registry to REG; default: rw.j2o.it
          -t TAG    Set the tag to apply to new images; default: latest

End-of-message
}

function build_push()
{
    local REGISTRY=$1
    local ARCH=$2
    local IMAGE=$3
    local TAG=$4
    local BUILD_DIR=$5

    # Set some defaults for the case we're building standard amd64 images
    # BUILD_ARG can be empty for amd64 because of Dockerfile defaults
    # BUILD_STR uses the Docker Hub convention: amd64 has no architecture field
    BUILD_ARG=""
    BUILD_STR="$REGISTRY/$IMAGE:$TAG"

    # If we're building for another architecture, change the above strings
    if [[ ! ${ARCH} =~ library ]]; then
       BUILD_ARG="--build-arg ARCH=$ARCH"
       # BUILD_STR munge $ARCH for building a dependent image, see file header
       BUILD_STR="$REGISTRY/${ARCH##*\/}/$IMAGE:$TAG"
    fi

    echo "Executing docker build $BUILD_STR arg $BUILD_ARG with context $BUILD_DIR"

    docker build --rm --force-rm ${BUILD_ARG} -t $BUILD_STR $BUILD_DIR || return 1

    echo "                       ---                                   "
    echo " SUCCESS: built $BUILD_STR"
    echo "                       ---                                   "

    #Docker push
    echo "Pushing $BUILD_STR"
    docker push $BUILD_STR
}

function process_files()
{
    # Parameters
    # $1 - File path from find
    # $2 - Registry
    # $3 - Arch
    # $4 - Tag

    local FILE_PATH=$1 # With: path/to/wget/Dockerfile
    local BUILD_DIR=${FILE_PATH%\/Dockerfile} # Gives us: path/to/wget
    local IMAGE=${BUILD_DIR##*\/} # Gives us: wget

    {
        # This is where we would build and push
        # build_push $REPO $IMAGE $TAG $BUILD_DIR
        $SCRIPT build_push "${2}" "${3}" "${IMAGE}" "$4" "${BUILD_DIR}"
    } || {
        echo "FAIL: Building ${IMAGE}:${4} for ${3} FAILED" >> $ERROR_FILE
    }
    echo
    echo
}

main()
{
    # Let's process the command line flags
    while getopts ":a:b:d:hr:t:" opt; do
        case $opt in
            a)
                # This is the comma-separated list of architectures
                IMG_ARC="${OPTARG}"
                ;;
            b)
                # This is the number of parallel jobs
                MAX_JOB="${OPTARG}"
                ;;
            d)
                # This is the docker directory containing all image/Dockerfile
                DCF_DIR="${OPTARG}"
                ;;
            h)
                # Display help and exit
                help
                exit 1
                ;;
            r)
                # This is the registry to use for the push
                OUR_REG="${OPTARG}"
                ;;
            t)
                # This is the tag to use for the new image
                OUR_TAG="${OPTARG}"
                ;;
            \?)
                echo "$SCRIPT: invalid option supplied: -$OPTARG"
                exit 1
                ;;
            :)
                echo "$SCRIPT: -$OPTARG requires an argument"
                exit 1
                ;;
        esac
    done

    # Use the command line params, or the following defaults:
    DCF_DIR="${DCF_DIR:-$(pwd)}"
    IMG_ARC="${IMG_ARC:-library}"
    OUR_REG="${OUR_REG:-rw.j2o.it}"
    MAX_JOB="${MAX_JOB:-2}"
    OUR_TAG="${OUR_TAG:-latest}"

    IFS=$'\n'
    # Generate a list of Dockerfiles (type 1 and 2)
    DCF_LIST=( $(find -L ${DCF_DIR} -iname "*Dockerfile" -not -path "*_*" | sort -d) )
    # Generate a list of Dockerfiles (type 3)
    DEP_LIST=( $(find -L ${DCF_DIR} -iname "*Dockerfile" -and -path "*_*" | sort -d) )
    unset IFS

    IFS=',' read -ra ARC_LIST <<< "$IMG_ARC"

    for ARCH in "${ARC_LIST[@]}"
    do
        # If some variant of i386 has been selected, use library instead
        if [[ $ARCH =~ [Xx]86-64|[Xx]86_64|[Aa][Mm][Dd]64|[Ii]ntel|[Ii]386 ]]
        then
            ARCH="library"
        fi

        if [ -x "$(command -v parallel)" ]
        then
            # This is where we call parallel with the array list:
            parallel --tag --verbose --ungroup -j"${MAX_JOB}" $SCRIPT process_files "{1}" "$OUR_REG" "$ARCH" "$OUR_TAG" ::: "${DCF_LIST[@]}"
            parallel --tag --verbose --ungroup -j"${MAX_JOB}" $SCRIPT process_files "{1}" "$OUR_REG" "$OUR_REG/$ARCH" "$OUR_TAG" ::: "${DEP_LIST[@]}"
        else
            # Parallel isn't installed, so let's perform the build(s) serially
            # Process the type 1 and type 2 Dockerfiles, that is those that can
            # be built without dependencies on others
            for DCF in "${DCF_LIST[@]}"
            do
                $SCRIPT process_files "$DCF" "$OUR_REG" "$ARCH" "$OUR_TAG"
            done

            # Process the type 3 Dockerfiles, that is those Dockerfiles that
            # depend on type 1 or type 2 Dockerfiles
            for DEP in "${DEP_LIST[@]}"
            do
                $SCRIPT process_files "$DEP" "$OUR_REG" "$OUR_REG/$ARCH" "$OUR_TAG"
            done
        fi
    done

    exit 0
}

if declare -f -- "$1" &> /dev/null
then
    # We've been called like this: path/script function <params>
    "$@"
else
    # We've been called without a function name, so execute main
    main "$@"
fi


